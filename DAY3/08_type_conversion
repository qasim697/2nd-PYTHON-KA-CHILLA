"""
Type Conversion (Casting) in Python - Notes + Executable Examples
File: 08_type_conversion.py
Place this file in:
C:/Users/qasim/OneDrive - Higher Education Commission/Documents/2nd PYTHON KA CHILLA/DAY3/08_type_conversion

Summary:
- Python is strongly typed but dynamically typed. Every value has a type.
- Conversion can be implicit (automatic) or explicit (done by programmer).
- Use built-in constructors/functions like int(), float(), str(), bool(), complex(),
      list(), tuple(), set(), dict(), bytes(), bytearray(), ord(), chr().
- Some conversions can fail (ValueError, TypeError). Use try/except where needed.
- Beware of precision issues when converting floats -> Decimal or when converting NaN/Inf to int.

Contents/examples:
1. Implicit conversion (numeric promotions)
2. Explicit numeric conversions: int, float, complex
3. String conversions: str, repr, formatting, int with base
4. Boolean conversions and truthiness rules
5. Sequence conversions: list, tuple, set, dict
6. Bytes and text conversions (encoding/decoding), bytes <-> int
7. Safe literal evaluation: ast.literal_eval
8. Decimal and Fraction for precise conversions
9. Common pitfalls and error handling
"""

# ---------------------------------------------------------------------------
# 1) Implicit conversion (numeric promotions)
# Python will promote smaller numeric types to bigger ones automatically.
a = 5          # int
b = 2.0        # float
c = a + b      # int + float -> float (implicit)
print("1) Implicit conversion:")
print("type(a):", type(a), "type(b):", type(b), "type(c = a+b):", type(c), "value:", c)
print()

# ---------------------------------------------------------------------------
# 2) Explicit numeric conversions
print("2) Explicit numeric conversions:")

# int() truncates toward zero (not rounding)
print("int(3.9) ->", int(3.9))
print("int(-3.9) ->", int(-3.9))

# float() converts ints, strings representing numbers
print("float(5) ->", float(5))
print("float('2.5') ->", float("2.5"))

# int() from string with base
print("int('101', 2) ->", int("101", 2))  # binary
print("int('ff', 16) ->", int("ff", 16))  # hex (lowercase allowed)

# complex() accepts numbers or strings that are valid complex literals
print("complex(2, 3) ->", complex(2, 3))
print("complex('1+2j') ->", complex("1+2j"))

# Edge cases: converting NaN/Infinity to int raises ValueError
import math
nan = float("nan")
inf = float("inf")
print("math.isnan(nan):", math.isnan(nan))
try:
            print("int(nan) ->", int(nan))
except ValueError as e:
            print("int(nan) raised:", type(e).__name__, e)
try:
            print("int(inf) ->", int(inf))
except OverflowError as e:
            print("int(inf) raised:", type(e).__name__, e)
print()

# ---------------------------------------------------------------------------
# 3) Strings and representation
print("3) Strings and representation:")

x = 123
s1 = str(x)       # user-friendly string
s2 = repr(x)      # representation often unambiguous (useful for debugging)
print("str(123):", s1, "repr(123):", s2)

# str() on containers
print("str([1,2,3]):", str([1, 2, 3]))

# formatting is often preferable to concatenation
print("Formatted string: {} + {} = {}".format(2, 3, 2 + 3))
print(f"f-string: {2} + {3} = {2 + 3}")

# converting strings that look like literals to Python objects:
import ast
literal = "[1, 2, 3]"
print("ast.literal_eval('[1,2,3]') ->", ast.literal_eval(literal))
# Do NOT use eval() on untrusted input; ast.literal_eval is safer for literals.
print()

# ---------------------------------------------------------------------------
# 4) Boolean conversions (truthiness)
print("4) Boolean conversions and truthiness:")

# False values: None, False, numeric zero, empty sequences/collections, empty mappings
candidates = [0, 0.0, 0j, "", [], (), {}, set(), None, False]
for val in candidates:
            print(f"bool({repr(val)}) ->", bool(val))
# Note: bool("False") is True because non-empty strings are truthy
print('bool("False") ->', bool("False"))
print()

# Converting booleans to ints:
print("int(True) ->", int(True), "int(False) ->", int(False))
print("float(True) ->", float(True))
print()

# ---------------------------------------------------------------------------
# 5) Sequence conversions: list, tuple, set, dict
print("5) Sequence conversions:")

s = "hello"
print("list('hello') ->", list(s))   # characters -> list
print("tuple([1,2]) ->", tuple([1, 2]))
print("set([1,2,2,3]) ->", set([1, 2, 2, 3]))

# dict conversions: from iterable of (key, value) pairs
pairs = [("a", 1), ("b", 2)]
print("dict([('a',1), ('b',2)]) ->", dict(pairs))

# Converting using map comprehensions; safe for parsing lists of numbers
str_nums = ["1", "2", "3"]
nums = list(map(int, str_nums))
print("list(map(int, ['1','2','3'])) ->", nums)
print()

# ---------------------------------------------------------------------------
# 6) Bytes and text conversions (encoding/decoding), bytes <-> int
print("6) Bytes and text conversions:")

text = "cafÃ©"                # Unicode text
b_utf8 = text.encode("utf-8")   # bytes in UTF-8
print("text:", text)
print("text.encode('utf-8') ->", b_utf8)

# decode back
print("b_utf8.decode('utf-8') ->", b_utf8.decode("utf-8"))

# bytes -> int, and int -> bytes
num = 1025
b_little = num.to_bytes(2, byteorder="little")
b_big = num.to_bytes(2, byteorder="big")
print("1025.to_bytes(2, 'little') ->", b_little)
print("1025.to_bytes(2, 'big') ->", b_big)
print("int.from_bytes(b'\\x01\\x04','little') ->", int.from_bytes(b"\x01\x04", "little"))

# bytes from hex
print("bytes.fromhex('ff0a') ->", bytes.fromhex("ff0a"))

# bytearray is mutable version of bytes
ba = bytearray(b"abc")
ba[0] = ord("z")
print("bytearray after mutation ->", ba)
print()

# ---------------------------------------------------------------------------
# 7) Safe literal evaluation: ast.literal_eval
print("7) Safe literal evaluation with ast.literal_eval:")
safe_examples = ["[1,2,3]", "{'a':1}", "('a', 2)"]
for lit in safe_examples:
            val = ast.literal_eval(lit)
            print(lit, "->", val, "type:", type(val))
# Dangerous: ast.literal_eval("os.system('rm -rf /')") will fail since it's not a literal;
# this demonstrates ast.literal_eval doesn't execute arbitrary code.
print()

# ---------------------------------------------------------------------------
# 8) Decimal and Fraction for precise numeric conversions
print("8) Decimal and Fraction (for precise arithmetic):")
from decimal import Decimal, getcontext
from fractions import Fraction

# Decimal: avoid binary-float rounding issues by converting from string
getcontext().prec = 28
d_from_str = Decimal("0.1")           # exact 0.1 in Decimal
d_from_float = Decimal(0.1)           # uses binary float -> not exact
print("Decimal('0.1') ->", d_from_str)
print("Decimal(0.1) ->", d_from_float)

# Fraction: rational representation
f = Fraction(1, 3)
print("Fraction(1,3) ->", f, "float(f) ->", float(f))
# Convert float to Fraction carefully:
frac_from_float = Fraction(0.75)      # exact for 0.75
print("Fraction(0.75) ->", frac_from_float)
print()

# ---------------------------------------------------------------------------
# 9) Common pitfalls and error handling
print("9) Common pitfalls and error handling:")

# ValueError when string is not a valid number
bad_int = "12a"
try:
            print("int('12a') ->", int(bad_int))
except ValueError as e:
            print("int('12a') raised:", type(e).__name__, e)

# TypeError when conversion isn't supported
try:
            print("int([1,2]) ->", int([1, 2]))  # cannot convert list directly to int
except TypeError as e:
            print("int([1,2]) raised:", type(e).__name__, e)

# Converting nested containers: use comprehension or map with recursive logic if needed
mixed = ["1", "2", "3"]
converted = [int(x) for x in mixed]
print("Converted list comprehension:", converted)

# Converting comma-separated numbers from a single string
csv = "10,20,30"
nums = [int(x) for x in csv.split(",")]
print("csv ->", csv, "->", nums)
print()

# ---------------------------------------------------------------------------
# Quick reference table (examples)
print("Quick reference (examples):")
print("int('10') ->", int("10"))
print("float('3.14') ->", float("3.14"))
print("str(123) ->", str(123))
print("bool(0) ->", bool(0))
print("complex(1, -1) ->", complex(1, -1))
print("list('abc') ->", list("abc"))
print("tuple([1,2]) ->", tuple([1, 2]))
print("set([1,2,2]) ->", set([1, 2, 2]))
print("dict([('k', 'v')]) ->", dict([("k", "v")]))
print("b'abc'.decode('utf-8') ->", b"abc".decode("utf-8"))
print("int.from_bytes(b'\\x01\\x00', 'little') ->", int.from_bytes(b"\x01\x00", "little"))
print()

# End of file note:
# - Prefer explicit conversions to make intentions clear.
# - Validate and handle errors for user-provided inputs.
# - Use Decimal or Fraction when exactness matters.
# - Use ast.literal_eval to safely convert strings that represent Python literals.
# - For performance-sensitive code, be mindful of creating many temporary objects when converting large structures.